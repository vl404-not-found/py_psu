Во время моего недавнего визита в США, я зашел в офис компании Adobe в Сан-Франциско для того, чтобы по больше разузнать про Apollo – новую платформу компании для разработки и выполнения RIA (Rich Internet Application). Я пообщался с Майком Чемберсом – продакт-менеджером ответственным за Apollo, чтобы узнать, что же такое на самом деле Apollo, и каково его будущее. Кристиан Контрелл, другой менеджер в команде Apollo, присоединился к нам в середине разговора, чтобы показать мне некоторые новые приложения сделанные с помощью Apollo.


В этом тексте я суммирую все то, что узнал об Apollo, а так же добавлю краткое описание «для чайников» (потому что до этой встречи я был одним из этих «чайников»). Почти все из того, что писалось уже об Apollo в блогах и СМИ отражало преимущества Apollo для разработчиков, я же хочу так же представить удобства Apollo для конечного пользователя, так что этот текст являет собой некую попытку это сделать.

Майк начал с того, что объяснил мне, что Apollo предназначен для того, чтобы перенести Интернет приложения на рабочий стол, в контрасте с Microsoft WPF (Windows Presentation Foundaiton, более известно как проект Avalon, графическая презентационная подсистема входящая в состав .NET Framework 3.0), который наоборот предназначен для перехода с рабочего стола в Интернет (идея не стоит того, хотя Майк и не считает, что Apollo противник WPF). Он так же сказал мне, что часто цитируемое преимущество Apollo – оффлайновый доступ к интернет приложениям, не является тем, из-за чего Adobe взялась за его разработку. Он сказал, что главной причиной было разрушить запреты, устанавливаемые браузерами, с улучшением интерфейса. По существу – Adobe планирует создать новый тип приложений, которые позволят пользователям запускать Интернет приложения с рабочего стола, как альтернативу или замену существующим браузерам.

Apollo все еще находится в стадии alpha версии, и, конечно же, Apollo не является финальным названием для проекта (новое название еще не было придумано, или просто держится в строжайшем секрете). Публичное бета тестирование начнется в начале лета в США, а выпуск первой версии запланирован на конец осени – начало зимы 2007 года.

Apollo в понимании дилетанта

Давайте вернемся назад на минутку, и определим все таки, что же такое Apollo, т.к. если вы не разработчик, то понять официальное описание этого продукта будет вам очень сложно. Вот это описание:

Apollo – это кодовое название для независимой от ОС среды запуска, созданной компанией Adobe для того, чтобы разработчики могли полноценно использовать свои навыки в создании приложения используя Flash, Flex, HTML, JavaScript, AJAX для разработки и переноса RIA (Rich Internet Application) на рабочий стол.


Для начала – богатый (rich) в данном случае значит, что Интернет приложения просто более интерактивны и графически усовершенствованы. Среда запуска (runtime), наверняка, является самым не доступным для простых пользователей понятием. Apollo, а по существу, среда запуска – это платформа, благодаря которой, можно создавать приложения. Браузер, например Firefox или IE, являет собой лучший пример среды запуска, точнее это самая распространенная среда запуска в Интернет. Он, конечно же, не запускает Интернет приложения, но он используется для обработки Интернет страниц.

Так зачем же создавать новую среду запуска, если браузер «достаточно хорош» и распространен для большинства Интернет приложений, включая RIA приложения (большинство приложений использующих AJAX работают замечательно в браузерах)? Apollo был создан для того, чтобы создать более богатые и более насыщенные оболочки для Интернет приложений. Чтобы добиться этого, Adobe создала платформу для Интернет приложений, которая в некоторых случаях может быть альтернативой браузеру, в других — заменой ему. Это потому, что приложения созданные с помошью Apollo, запускаются с рабочего стола, используя среду запуска Apollo. Так же заметьте, что разработчик может переносить AJAX приложения используя Apollo.

Перспективы для разработчиков таковы, что они могут использовать свои навыки в разработке Интернет приложений для рабочего стола, например, используя Apollo, перенести свои существующие Интернет приложения для браузеров. Несомненно, это является первостепенной функцией Apollo.

Так же, Adobe нацелена на создание более легковесных приложений для рабочего стола, чем предыдущие среды запуска, например, Sun Java (популярная в 90-х) и Microsoft .Net. Легковесность заключается, на самом деле, в том, сколько мегабайт вам нужно скачать из Интернета для запуска среды. Важно помнить, что для запуска любого приложения на рабочем столе, вам нужны библиотеки. Например, для запуска приложений использующих Java, вам нужно загрузить примерно 12-13 мегабайт, а в случае с .Net скачать нужно уже более 50 мегабайт. Майк Чемберс сказал, что Adobe планирует уложиться примерно в 6 мегабайт, что значительно меньше, чем у ее противников. Так же, он отметил, что у приложений использующих Apollo не будет проблем с совместимостью версий, как это было у ранних версий Java.

Примеры ранних приложений написанных с использованием Apollo

Майк Чемберс и Кристиан Контрелл показали мне несколько приложений, написаных с использованием Apollo, и многие из них являли собой переработки существующих Интернет приложений для браузеров. Не забывайте, что Apollo пока еще находится в стадии alpha, так что приложений пока что мало. Два самых завораживающих приложения были Finetune (музыкальный проигрыватель похожий на last.fm и pandora) и приложение использующее Apollo для eBay Desktop (кодовое название – проект San Dimas).

Finetune – это персонализированное радио в частности, основанное на HTML, но проигрыватель сам по себе использует Flash. Изначально Fintune был написан, как приложение для браузера, но в последствии, с помощью Apollo, был переработан в приложение для рабочего стола. Хотя он и является переработаной версией браузерного приложения, Finetune содержит в себе несколько дополнительных возможностей, которые делают его привлекательным для продвинутых пользователей. Например, он может интегрироваться с iTunes, это то, чего браузер сделать не сможет. На самом деле, это делается двумя приложениями Finetune и iTunes, совместно использующими XML файлы. Adobe видит Finetune, как классическое использование для приложений, разрабатываемых с использованием Apollo, когда разработчики могут создавать кросс-платформеные приложения, использующие Интернет технологии.

Так же, для продвинутых пользователей, создан eBay Desktop. У Райна Стюарта есть замечательное описание этого приложения, но, на самом деле eBay Desktop, позволяет пользователям управлять их аукционами, используя приложение для рабочего стола, которое предлагает улучшенное кэширование, сообщение о появлении продукта в реальном времени и обновление аукционов.

Другой пример, который мне показали Майк и Кристиан – это Adobe Media Player (кодовое название – Philo, в честь одного из изобретателей телевизора). Это приложение для просмотра телевидения в режиме онлайн и противник Microsoft Windows Media Player, но Майк сказал, что, на самом деле, это видео агрегатор, использующий RSS, и плеер в одном лице. Используя Apollo, компании могут распространять Adobe Media Player, используя особый RSS код. Сравните это с iTunes, который является продуктом исключительно компании Apple. Adobe Media Player, так же, позволяет компаниям поставлять рекламные блоки, используя RSS, включая видео вставки, когда реклама вставляется прямо в видео материалы.



В завершении

Конечные пользователи вряд ли увидят полный потенциал Apollo до того, как он выйдет в публичное beta тестирование в начале лета в США, что даст возможность большему количеству разработчиков использовать его.

Так же ясно, что Adobe видит блестящее будущее для Интернет приложений за пределами браузеров, хотя при этом на 95% компьютеров установлен Flash, поэтому браузеры все еще будут играть ключевую роль в их планах. Adobe, так же, осторожно акцентирует внимание на том, что приложения использующие Apollo будут сосуществовать с браузерами, так же, создавая им альтернативу. В это время Microsoft так же разрабатывает платформу для приложений для рабочего стола, но при это продолжает придавать браузеру ключевую роль в своей экосистеме. В случае с Microsoft, ее браузер преобладает в мире, он установлен более чем на 80% компьютеров, и Silverlight является дополнением к браузеру, некое подобие Flash. И Microsoft, и Adobe хотят избавиться от браузерной зависимости, хотя оба при этом обладают продуктами предназначеными для браузеров (Flash в случае с Adobe, Silverlight в случае с Microsoft). Это ничто, с учетом того, что Adobe видит себя больше приверженной к Интернет технологиям и кросс-платформеным приложениям, чем Microsoft, ведь в интересах компании развивать доминирование Windows в мире.

Каково ваше мнение об Apollo, каковы его шансы в будущем? Это очень опасный рынок, на котором присутствуют такие компании, как Adobe, Microsoft, Sun, Google и другие активные участники, и у каждой компании свои собственные взгляды на разработку Интернет приложений. Google, все еще, привязан к браузерам, в то время как Microsoft и Adobe сделали первые, хотя все еще неуверенные, шаги к избавлению от браузерной зависимости. Так же давайте не забудем о том, что Mozilla и другие браузеры продолжают развиваться, улучшая качество их продукции в быстром темпе.
Всем привет, меня зовут Семен Левенсон, я работаю teamlead’ом на проекте «Поток» от Rambler Group и хочу рассказать о нашем опыте использования Apollo.


Объясню, что такое «Поток». Это автоматизированный сервис для предпринимателей, позволяющий привлекать клиентов из Интернета в бизнес, не вовлекаясь в рекламу, и быстро создавать простые сайты, не являясь экспертом в верстке.


На скришноте показан один из шагов создания лендинга.





Что было вначале?

А в начале было MVP, много Twig, JQuery и очень сжатые сроки. Но мы пошли нестандартным путем и решили сделать редизайн. Редизайн не в смысле «стили подлатать», а решили пересмотреть полностью работу системы. И это стало для нас хорошим этапом для того, чтобы собрать идеальный frontend. Ведь нам – команде разработчиков – дальше поддерживать это и реализовывать на основе этого другие задачи, достигать новых целей, поставленных продуктовой командой.


В нашем отделе уже было накоплено достаточно экспертизы по использованию React. Не хотелось тратить 2 недели на настройку webpack, поэтому решили использовать CRA (Create React App). Для стилей был взят Styled Components, и куда же без типизации – взяли Flow. Для State Management взяли Redux, однако в результате оказалось, что он нам вообще не нужен, но об этом чуть позже.


Мы собрали свой идеальный frontend и поняли, что о чем-то забыли. Как выяснилось, забыли мы про backend, а точнее про взаимодействие с ним. Когда задумались, что можем использовать для организации этого взаимодействия, то первое, что пришло на ум – конечно, это Rest. Нет, мы не пошли отдыхать (smile), а начали рассуждать на тему RESTful API. В принципе история знакомая, тянется давно, но также нам известны и проблемы с ним. О них мы и поговорим.


Первая проблема – это документация. RESTful, конечно, не говорит, как организовать документацию. Здесь существует вариант использования того же swagger, но фактически — это внедрение дополнительной сущности и усложнение процессов.


Вторая проблема – это как организовать поддержку версионности API.


Третья важная проблема – это большое количество запросов или кастомные endpoint’ы, которые мы можем нагородить. Допустим, нам нужно запрашивать посты, по этим постам – комменты и еще авторов этих комментов. В классическом Rest’е нам приходится делать 3 запроса минимум. Да, мы можем нагородить кастомные endpoint’ы, и все это свернуть в 1 запрос, но это уже усложнение.



За иллюстрацию спасибо Sashko Stubailo


Решение

И в этот момент нам на помощь приходит Facebook c GraphQL. Что такое GraphQL? Это платформа, но сегодня мы рассмотрим одну из ее частей – это Query Language for your API, просто язык, причем довольно примитивный. И работает он максимально просто – как мы запрашиваем какую-то сущность, также мы ее и получаем.


Запрос:


{
  me {
    id
    isAcceptedFreeOffer
    balance
  }
}

Ответ:


{
  "me": {
    "id": 1,
    "isAcceptedFreeOffer": false,
    "balance": 100000
  }
}

Но GraphQL — это не только про чтение, это и про изменение данных. Для этого в GraphQL существуют мутации. Мутации примечательны тем, что мы можем декларировать желаемый ответ от backend’а, при успешном изменении. Однако тут есть свои нюансы. Например, если наша мутация затрагивает данные за пределом графа.


Пример мутации, в которой применяем бесплатную оферту:


mutation {
  acceptOffer (_type: FREE) {
    id
    isAcceptedFreeOffer
  }
}

В ответ получаем ту же структуру, которую запросили


{
  "acceptOffer": {
    "id": 1,
    "isAcceptedFreeOffer": true
  }
}

Взаимодействие с GraphQL бекендом может совершается с помощью обычного fetch.


fetch('/graphql', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ query: '{me { id balance } }' })
});

Какие же плюсы у GraphQL?

Первый и очень крутой плюс, который можно оценить, когда вы начинаете с ним работать, в том, что этот язык – строготипизированный и самодокументируемый. Проектируя схему GraphQL на сервере, мы можем сразу описывать типы и атрибуты непосредственно в коде.





Как уже было сказано выше, у RESTful есть проблема с версионированием. В GraphQL для этого осуществлено весьма элегантное решение – deprecated.





Допустим, у нас есть Film, мы расширяем его, так у нас появляется director. И в какой-то момент мы просто выносим director в отдельный тип. Возникает вопрос, что делать с прошлым полем director? На него есть два ответа: либо мы удаляем это поле, либо же помечаем его deprecated, и оно автоматически пропадает из документации.


Самостоятельно решаем, что нам нужно.


Вспоминаем предыдущую картинку, где у нас все шло REST’ом, здесь же у нас все объединяется в один запрос и не требует какой-то кастомизации со стороны backend-разработки. Они один раз это все описали, а мы уже крутим-вертим-жонглируем.





Но не обошлось без ложки дегтя. В принципе на frontend’е у GraphQL минусов не так уж и много, потому что он изначально разрабатывался для того, чтобы решать проблемы frontend’а. А у backend’а не все так гладко… У них есть такая проблема, как N+1. Возьмем в качестве примера запрос:


{
  landings(_page: 0, limit: 20) {
    nodes {
      id
      title
    }
    totalCount
  }
}

Простой запрос, мы запрашиваем 20 сайтов и количество, сколько у нас есть сайтов. И в backend’е это может обернуться 21 запросом к базе данных. Эта проблема известная, решаемая. Для Node JS есть пакет dataloader от Facebook. Для других языков можно найти свои решения.


Также существует проблема глубокой вложенности. К примеру, у нас есть альбомы, у этих альбомов есть песни, и через песню мы также можем получить альбомы. Для этого необходимо составить следующие запросы:


{
  album(id: 42) {
    songs {
      title
      artists
    }
  }
}

{
  song(id: 1337) {
    title
    album {
      title
    }
  }
}

Таким образом, у нас получается рекурсивный запрос, который тоже элементарно кладет нам базу.


query evil {
  album(id: 42) {
    songs {
      album {
        songs {
          album {

Данная проблема тоже известная, решение для Node JS – это GraphQL depth limit, для других языков также существуют свои решения.


Таким образом, мы определились с GraphQL. Самое время – выбрать библиотеку, которая будет работать с GraphQL API. Пример в пару строк с fetch’ем, который показан выше, это только транспорт. Но благодаря схеме и декларативности, мы можем кэшировать еще и запросы на front’е, и работать с большей производительностью с GraphQL backend’ом.


Так у нас есть два основных игрока – это Relay и Apollo.


Relay

Relay — это разработка Facebook, они используют его сами. Как и Oculus, Circle CI, Arsti и Friday.


Какие плюсы есть у Relay?

Непосредственный плюс — то что разработчиком является Facebook. React, Flow и GraphQL – это разработки Facebook, всё это заточенные друг под друга паззлы. Куда же нам без звездочек на Github, у Relay их почти 11 000, у Apollo для сравнения – 7600. Крутая вещь, которая есть у Relay – это Relay-compiler, инструмент, который оптимизирует и анализирует ваши GraphQL-запросы на уровне сборки вашего проекта. Можно считать, что это uglify только для GraphQL:


# до Relay-compiler
foo { # type FooType
   id
   ... on FooType { # matches the parent type, so this is extraneous
     id
   }
 }
# После
foo {
  id
}

Какие минусы у Relay

Первый минус* – отсутствие SSR из коробки. На Github до сих пор открыт issue. Почему под звездочкой – потому что уже есть решения, но они сторонние, а кроме того, довольно неоднозначные.





Опять же, Relay — это спецификация. Дело в том, что GraphQL – это уже спецификация, а Relay – это спецификация над спецификацией.





Например, пагинация у Relay реализована иначе, здесь появляются курсоры.


{
  friends(first: 10, after: "opaqueCursor") {
    edges {
      cursor
      node {
        id
        name
      }
    }
    pageInfo {
      hasNextPage
    }
  }
}

Мы уже не используем привычные оффсеты и лимиты. Для фидов в ленте – это отличная тема, но когда мы начинаем делать всякие grid’ы, то тут появляется боль.


Facebook решил свою проблему, написав для React’a свою библиотеку. Существуют решения для других библиотек, для vue.js, например – vue-relay. Но если мы обратим внимание на количество звездочек и commit-ов, то тут тоже не всё так гладко и может быть нестабильно. Например, Create React App из коробки CRA не дает использовать Relay-compiler. Но можно обойти это ограничение с помощью react-app-rewired.





Apollo

Второй наш кандидат – это Apollo. Разрабатывает его команда Meteor. Apollo используют такие известные команды как: AirBnB, ticketmaster, Opentable и т.д.


Какие есть плюсы у Apollo

Первый значительный плюс в том, что Apollo разрабатывался, как framework agnostic библиотека. Например, если мы захотим сейчас все переписать на Angular, то это не будет проблемой, Apollo с этим работает. А можно вообще написать все на Vanilla.


У Apollo крутая документация, есть готовые решения на типичные проблемы.





Очередной плюс Apollo – мощный API. В принципе, кто работал с Redux, здесь найдут общие подходы: есть ApolloProvider (как Provider у Redux), и вместо store у Apollo это называется client:


import { ApolloProvider } from 'react-apollo';
import { ApolloClient } from './ApolloClient';

const App = () => (
  <ApolloProvider client={ApolloClient}>
    ...
  </ApolloProvider>
);

На уровне уже самого компонента, у нас предоставляется graphql HOC, как connect. И GraphQL-запрос мы пишем уже внутри, как MapStateToProps в Redux.


import { graphql } from 'react-apollo';
import gql from 'graphql-tag';
import { Landing } from './Landing';
graphql(gql`
  {
    landing(id: 1) {
      id
      title
    }
  }
`)(Landing);

Но когда мы делаем MapStateToProps в Redux, мы забираем данные локальные. Если же локальных данных нет, то Apollo сам идет за ними на сервер. В сам компонент нам падают очень удобные Props-ы.


function Landing({
  data,
  loading,
  error,
  refetch,
  ...other
}) {
  ...
}

Это:
• данные;
• статус загрузки;
• ошибка, если она произошла;
вспомогательные функции, например refetch для перезагрузки данных или fetchMore для пагинации. Также есть огромный плюс и у Apollo, и у Relay, это Optimistic UI. Он позволяет совершать undo/redo на уровне запросов:


this.props.setNotificationStatusMutation({
  variables: {
    …
  },
  optimisticResponse: {
    …
  }
});

Например, пользователь нажал на кнопку «лайк», и «лайк» сразу засчитался. При этом запрос на сервер будет отправлен в фоне. Если в процессе отправки произойдет какая-то ошибка, то, изменяемые данные, вернуться в первоначальное состояние самостоятельно.


Server side rendering реализован хорошо, на клиенте выставляем один флаг и всё готово.


new ApolloClient({
  ssrMode: true,
  ...
});

Но здесь хотелось бы рассказать про Initial State. Когда Apollo сам себе его готовит, все хорошо работает.


<script>
  window.__APOLLO_STATE__ = client.extract();
</script>

const client = new ApolloClient({
  cache: new InMemoryCache().restore(window.__APOLLO_STATE__),
  link
});

Но у нас нет Server side rendering, а нам backend подсовывает в глобальную переменную определенный GraphQL-запрос. Тут нужен небольшой костыль, необходимо написать Transform-функцию, которая GraphQL-ответ от backend’а уже превратит в нужный для Apollo формат.


<script>
  window.__APOLLO_STATE__ = transform({…});
</script>

const client = new ApolloClient({
  cache: new InMemoryCache().restore(window.__APOLLO_STATE__),
  link
});

Ещё один плюс Apollo в том, что он хорошо кастомизируется. Все мы помним middleware из Redux, здесь всё тоже самое, только это называется link.





Хотелось бы отдельно отметить два link’а: apollo-link-state, который нужен для того, чтобы в отсутствие Redux хранить локальное состояние, и apollo-link-rest, если мы хотим писать GraphQL-запросы к Rest API. Однако с последним нужно быть крайне аккуратным, т.к. могут возникнуть определенные проблемы.


Минусы у Apollo тоже есть

Рассмотрим на примере. Возникла неожиданная проблема с производительностью: запрашивали 2000 элементов на frontend (это был справочник), и начались проблемы с производительностью. После просмотра в отладчике оказалось, что на чтении Apollo отъедал очень много ресурсов, issue в принципе закрыт, сейчас все хорошо, но такой грешок был.


Также refetch оказался очень неочевидный…


function Landing({
  loading,
  refetch,
  ...other
}) {
  ...
}

Казалось бы, когда мы делаем перезапрос данных, тем более, если предыдущий запрос завершился с ошибкой, то loading должен стать true. Но нет!


Для того, чтобы это было, нужно указывать notifyOnNetworkStatusChange: true в graphql HOC, или refetch state хранить локально.


Apollo vs. Relay

Таким образом, у нас получилась такая таблица, мы все взвесили, подсчитали, и у нас 76% оказалось за Apollo.





Таким образом, мы выбрали библиотеку и пошли работать.


Но хотелось бы подробнее сказать про toolchain.


Здесь вообще все очень хорошо, существуют различные дополнения для редакторов, где-то лучше, где-то хуже. Также есть еще apollo-codegen, который генерирует полезные файлы, к примеру, flow-типы, и в принципе вытаскивает схему из GraphQL API.


Рубрика «Очумелые ручки» или что мы сделали у себя

Первое, с чем мы столкнулись, — что нам в принципе надо как-то запрашивать данные.


graphql(BalanceQuery)(BalanceItem);

У нас есть общие состояния: загрузка, обработка ошибки. Мы написали свой хок (asyncCard), который подключается через композицию graqhql и asyncCard’а.


compose(
  graphql(BalanceQuery),
  AsyncCard
)(BalanceItem);

Хотелось бы еще рассказать про фрагменты. Есть компонент LandingItem и он знает, какие данные ему нужны из GraphQL API. Мы задали свойство fragment, где указали поля из сущности Landing.


const LandingItem = ({ content }: Props) => (
  <LandingItemStyle>
    …
  </LandingItemStyle>
);
LandingItem.fragment = gql`
  fragment LandingItem on Landing {
    ...
  }
`;

Теперь на уровне использования компонента мы используем его фрагмент в конечном запросе.


query LandingsDashboard {
  landings(...) {
    nodes {
      ...LandingItem
    }
    totalCount
  }
  ${LandingItem.Fragment}
}

И допустим к нам прилетает задача на то, чтобы добавить статус в этот лендинг — не проблема. Мы добавляем в рендер отображение и в фрагменте свойство. И все, готово. Single responsibility principle во всей красе.


const LandingItem = ({ content }: Props) => (
  <LandingItemStyle>
    …
    <LandingItemStatus … />
  </LandingItemStyle>
);
LandingItem.fragment = gql`
  fragment LandingItem on Landing {
    ...
    status
  }
`;

Какая у нас еще была проблема?

У нас на сайте есть ряд виджетов, которые делали свои отдельные запросы.





Во время тестирования оказалось, что всё это тормозит. У нас очень долгие security-проверки, и каждый запрос очень дорогой. Это тоже оказалась не проблема, есть Apollo-link-batch-http


new BatchHttpLink({ batchMax: 10, batchInterval: 10 });

Он конфигурируется следующим образом: мы передаем количество запросов, которые мы можем объединить и сколько времени будет ждать этот link после появления первого запроса.
И получилось так: одновременно всё загружается, и одновременно всё приходит. Стоит отметить, что если во время этого объединения какой-то из подзапросов вернется с ошибкой, то ошибка будет только у него, а не у всего запроса.


Хочется отдельно рассказать, что прошлой осенью произошло обновление с первого Apollo на второй

Вначале был Apollo и Redux


'react-apollo'
'redux'

Потом Apollo стал более модульным и расширяемым, эти модули можно разрабатывать самостоятельно. Тот же самый apollo-cache-inmemory.


'react-apollo'
'apollo-client'
'apollo-link-batch-http'
'apollo-cache-inmemory'
'graphql-tag'

Стоит обратить внимание, что Redux нет, и как оказалось, он, в принципе, не нужен.


Выводы:

Feature-delivery time у нас уменьшился, мы не тратим времени на описание action, reduce в Redux, и меньше трогаем backend
Появилась антихрупкость, т.к. статический анализ API позволяет свести к нулю проблемы, когда frontend ожидает одно, а backend отдает совершенно другое.
Если вы начнете работать с GraphQL – попробуйте Аполло, не разочаруетесь.

Автор материала, перевод которого мы публикуем сегодня, говорит, что миссия разработчиков Apollo Client заключается в том, чтобы сделать этот инструмент самым современным и удобным решением для управления состоянием React-приложений. Сообщество React развивается и осваивает новые эффективные способы разработки пользовательских интерфейсов. Создатели Apollo Client стремятся к тому, чтобы их проект поддерживал бы всё самое актуальное из мира React. Следуя этой традиции, разработчики Apollo Client представляют новую версию системы, оснащённую поддержкой хуков React.

image

Хуки были представлены в React 16.8. Это — новый механизм, позволяющий создавать компоненты, обладающие состоянием, и при этом не сталкиваться с проблемами, характерными для компонентов, основанных на классах. Сейчас Apollo Client включает в себя три хука, которые можно использовать в приложениях — во всех тех местах, где используются компоненты высшего порядка или механизмы render props. Речь идёт о хуках useQuery, useMutation и useSubscription. Эти хуки просты в освоении, они обладают множеством преимуществ перед ранее существовавшим API. В частности, это касается уменьшения размеров бандла приложения и сокращение объёма шаблонного кода.

Начало работы

Если вы собираетесь создать новый Apollo-проект — мы рекомендуем установить следующий пакет после того, как вы настроили свой экземпляр Apollo Client:

npm install @apollo/react-hooks

Этот пакет экспортирует компонент ApolloProvider, использующийся для подключения Apollo Client к React-приложению. По такой же схеме работа была организована и с использованием старого API.

Если у вас уже есть проект, в котором используется Apollo, это значит, что у вас имеется несколько способов по переходу на хуки. Выбор конкретного способа зависит от того, как именно вы хотите совершить переход. Подробности об этом можно найти здесь.

Почему хуки — это будущее?

Apollo Client всё ещё поддерживает API, основанные на компонентах высшего порядка и на render props. Эти API будут присутствовать в системе ещё некоторое время. Мы полагаем, что в будущем хуки окажутся наилучшим механизмом загрузки данных с помощью Apollo Client. Хотя тем, кто уже пользуется Apollo, необязательно прямо сейчас переходить на хуки, им стоит использовать хуки для новых компонентов. У этой рекомендации есть несколько причин, которые мы сейчас рассмотрим.

?При использовании хуков нужно меньше кода, используемого для работы с данными

Хуки уменьшают объёмы шаблонного кода, используемого для работы с данными. Это ведёт к сокращению размеров компонентов и к тому, что в подобных компонентах оказывается легче разобраться. В результате разработчикам больше не понадобится вникать в то, как устроены компоненты высшего порядка, или анализировать сложную логику механизмов render props. Для загрузки данных достаточно вызывать единственную функцию useQuery:

const LAST_LAUNCH = gql`
  query lastLaunch {
    launch {
      id
      timestamp
    }
  }
`;

export function LastLaunch() {
  const { loading, data } = useQuery(LAST_LAUNCH);
  return (
    <div>
      <h1>Last Launch</h1>
      {loading ? <p>Loading</p> : <p>Timestamp: {data.launch.timestamp}</p>}
    </div>
  );
}

Здесь показана загрузка данных с помощью хука Apollo Client useQuery
Взгляните на это учебное приложение, в котором можно увидеть работающий пример использования хуков Apollo Client.

?Множественные мутации

Когда вы выполняете множественные мутации в одном компоненте, использование компонентов высшего порядка или механизма render props может привести к появлению кода, который сложно будет понять. Применение API render prop, построение конструкций, состоящих из вложенных друг в друга компонентов Mutation, даёт ложное ощущение структурированности кода и его чёткой иерархии. Новый хук useMutation позволяет полностью обойти эту проблему. Дело в том, что его использование сводится к простому вызову функции. В следующем примере показано то, как несколько мутаций и запросов могут друг с другом взаимодействовать. Всё это происходит в пределах одного и того же компонента:

function Message() {
  const [saveMessage, { loading }] = useMutation(SAVE_MESSAGE);
  const [deleteMessage] = useMutation(DELETE_MESSAGE);
  const { data } = useQuery(GET_MESSAGE);

  return (
    <div>
      <p>
        {loading
          ? 'Loading ...'
          : `Message: ${data && data.message ? data.message.content : ''}`}
      </p>
      <p>
        <button onClick={() => saveMessage()}>Save</button>
        <button onClick={() => deleteMessage()}>Delete</button>
      </p>
    </div>
  );
}

Здесь используется хук useMutation. Увидеть множественные мутации в действии можно здесь. Это приложение-пример, кроме того, содержит похожий компонент, созданный с помощью render props. Это даёт вам возможность сравнить данный компонент с тем, который создан с использованием хуков.

?Улучшенная поддержка TypeScript

Ни для кого не секрет то, что мы — большие фанаты TypeScript. Возможности новых хуков отлично сочетаются с автоматическими определениями типов, генерируемыми с помощью Apollo CLI. Это значительно облегчает написание типобезопасного кода React-компонентов. Вот как выглядит загрузка данных с использованием хука useQuery и TypeScript:

import { RocketData, RocketVars } from './types';

const GET_ROCKET_INVENTORY = gql`
  query getRocketInventory($year: Int!) {
    rocketInventory(year: $year) {
      id
      year
    }
  }
`;

export function RocketInventoryList() {
  const { loading, data } = useQuery<RocketData, RocketVars>(
    GET_ROCKET_INVENTORY,
    { variables: { year: 2019 } }
  );
  return (/* ... show data ... */);
}

Хуки Apollo и TypeScript облегчают разработку строго типизированных компонентов React.

Дополнительные улучшения Apollo Client для React-разработчиков

Хотя в этом релизе Apollo основное внимание уделяется новым хукам, мы можем рассказать и о ещё некоторых интересных новых возможностях.

?Уменьшение размеров бандла на 50%

В то время как размер минифицированного и сжатого gzip пакета react-apollo@2 составляет 10.6 Кб, размер пакета react-apollo@3 оказывается равным лишь 7.8 Кб. Более того, если вам достаточно пакета @apollo/react-hooks, то размер бандла уменьшается до всего 5.1 Кб. Это даёт 50% экономию по сравнению с react-apollo@2.

?Отложенное выполнение запросов

Хук useQuery выполняет свой запрос в момент вызова функции. Но именно такое поведение системы нужно не всегда. Представьте себе, например, поле для ввода поискового запроса, выдающее пользователю подсказки. Вам может понадобиться вывести компонент с таким полем, готовым принять то, что введёт пользователь. Но при этом выполнение запроса к поисковому серверу будет отложено до того момента, когда пользователь начнём что-то в поле вводить. Для реализации подобного сценария можно воспользоваться хуком useLazyQuery, который возвращает кортеж с функцией execute во второй позиции:

const [execute, { loading, data }] = useLazyQuery(GET_INVENTORY);

Запрос не будет выполнен до тех пор, пока вы не вызовете функцию execute. В этот момент компонент повторно отрендерится и будет применена обычная схема выполнения запросов, реализуемая с помощью useQuery.

?Новая документация по API

Мы обновили документацию по Apollo Client, добавив туда сведения о хуках. Именно их мы рекомендуем использовать тем, кто только начал работу с нашей системой. Правда, несмотря на это, мы не убирали из документации сведения о том, как работать с компонентами высшего порядка и с механизмом render props. В примерах кода, которые можно найти в документации, теперь можно воспользоваться новым выпадающим меню, позволяющим переключаться между кодом, демонстрирующим решение одной и той же задачи с использованием подхода, который больше всего нравится читателю.



Различные варианты кода, доступные в документации
Итоги

Создатели Apollo Client говорят, что в React им больше всего нравится то, что основная команда разработчиков этой библиотеки и сложившееся вокруг неё сообщество энтузиастов постоянно стремятся к улучшению удобства работы с React с точки зрения программиста. Появление хуков, попробовать которые рекомендуется абсолютно всем, представляет собой один из ярких примеров подобного стремления.

Надеемся, что хуки React, появившиеся в Apollo Client, понравятся тем, кто применяет этот проект при разработке своих приложений.


Меня зовут Oveveveevuev eyentanebwueve ugmbagbem osas!

абоба
